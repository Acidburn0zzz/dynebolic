#!/bin/sh
#
# dyne:bolic software development kit - the commandline tool
#
# Copyright (C) 2003-2005 Denis "Jaromil" Rojo <jaromil@dyne.org>
#                    Alex "Smilzo" Gnoli    <smilzo@sfrajone.org>
#                    Pierluigi "Newmark" Maori <newmark@dyne.org>
#
# This source code is free software; you can redistribute it and/or
# modify it under the terms of the GNU Public License as published 
# by the Free Software Foundation; either version 2 of the License,
# or (at your option) any later version.
#
# This source code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

if [ -r /lib/dyne/utils.sh ]; then
  source /lib/dyne/utils.sh
else
  # standard output message routines
  # it's always useful to wrap them, in case we change behaviour later
  notice() { echo "[*] $1"; }
  act() { echo " .  $1"; }
  error() { echo "[!] $1"; }
fi
func() { if [ $DEBUG ]; then echo "[D] $1"; fi }

PACKAGE="dyne:bolic SDK"
VERSION="2.0"
ISO="dyneII-dev.iso"
if [ -z $DYNESDK ]; then
  PFX="$DYNE_SYS_MNT/dyne/SDK" # you can change it to static path where dynesdk resides
else
  PFX=${DYNESDK}
fi

notice "$PACKAGE version $VERSION - software development kit"
act "Copyleft 2003-2005 by jaromil - RASTASOFT"

OPTS=`getopt -o hvp:u:r:i:s:m:q -n 'dynesdk' -- "$@"`

#eval set -- "$OPTS"

while true; do
    case "$1" in
	-h)
	    notice "SYNOPSIS: dynesdk [-hv] [-p prefix] [-u user -h host] COMMAND"
	    act "-h     print this help"
	    act "-v     print out the version of this sdk tool"
	    act "-p     path to the sdk base directory (default /SDK)"
	    act "-s     partition where to settle (default ask)"
            act "-m     additional modules to add in ramdisk"
            act "-q     be quick and skip checksums and crypto sigs"

	    notice "COMMANDS:"
	    act "settle     settle a writable installation on harddisk"
	    act "mkinitrd   makes an initrd.gz of INITRD_SIZE (8192KB)"
	    act "mkhome     packs the home into the cdrom directory"
	    act "mkvar      packs the var into the cdrom directory"
	    act "mksquash   packs the squashed filesystem in the cdrom"
	    act "mkmods     packs all the add-on modules into the cdrom"
	    act "mkiso      packs the cdrom directory into a bootable iso"

	    echo; exit 2 ;;
	-v) exit 2 ;;
	-p) PFX=$2; shift 2 ;;
	-s) SETTLE=$2; shift 2 ;;
	-m) ADD_RAMDISK_MODULES=$2; shift 2 ;;
        -q) QUICK="yes"; shift 1 ;;
	--) shift; break ;;
	*)  CMD=$1; shift 1; break ;;
    esac
done

# function to check for required software
check_sw() {
    func "checking existance of $1"
    CHECK_SW="`which $1`"
    if [ -z $CHECK_SW ]; then
	error "$1 not found"
	RET=0
    else
	func "$1 found in $CHECK_SW"
	RET=$CHECK_SW
    fi
}

if [ "`whoami`" != root ]; then
    error "you must be ROOT on your machine to use dyne:bolic SDK"
    exit -1
fi

if [ ! $CMD = mksdk ]; then
  if [ ! -x "$PFX" ]; then
    error "the SDK directory is not existing"
    error "create the directory $PFX or set the -p option properly"
    exit 0
  fi
fi

# if those are missing, the iso can't be packed
if [ -z $MKISOFS ]; then
    check_sw "mkisofs";
    if [ $RET ]; then MKISOFS=$RET; fi
fi
if [ -z $MKSQUASHFS ]; then
    check_sw "mksquashfs";
    if [ $RET ]; then MKSQUASHFS=$RET; fi
fi


########################################################################
### COMMAND FUNCTIONS
########################################################################

mksdk() {

  if [ ! -x $DYNE_SYS_MNT/dyne ]; then

      error "no dyne/ system directory found"
      error "specify it in DYNE_SYS_MNT environmental variable"
      exit -1
	  
  elif [ -x $DYNE_SYS_MNT/dyne/SDK ]; then

      error "an SDK is already present in your active dock"
      error "please check $DYNE_SYS_MNT/dyne/SDK"
      exit -1
      
  else
      
      source $DYNE_SYS_MNT/dyne/VERSION
      notice "creating SDK inside $DYNE_SYS_MNT/dyne"
      act "version: sys $DYNE_SYS_VER - initrd $DYNE_INITRD_VER"
      
  fi
  
  cd ${DYNE_SYS_MNT}/dyne
  mkdir SDK

  act "I can uncompress dyne.sys, it will occupy approx 2Gb"
  act "this way your /usr will become writable."
  act "You should do it only if you really need: it will make"
  act "it harder to merge your modifications with upgrades to"
  act "the dyne core."
  echo "[?] do you want to uncompress the dyne.sys (y/N) ?"
  ask_yesno 10
  if [ $? = 1 ]; then
    mkdir tmp
    mkdir SDK/sys
    act "uncompressing usr binaries from ${DYNE_SYS_MNT}/dyne/dyne.sys"
    act "please wait, this operation requires long time..."
    mount -o loop dyne.sys tmp
    cp -rau tmp/* SDK/sys/
    umount tmp
    rm -r tmp
  fi


  act "downloading dyne:II liveCD skeleton files from online repository"
  cd - > /dev/null
  cd ${DYNE_SYS_MNT}/dyne/SDK
  svn co svn://dyne.org/dynebolic/dyneII/startup
  svn co svn://dyne.org/dynebolic/dyneII/cdrom
  # mkdir tmp initrd var home

  act "downloading dyne:II kernel source and modules"
  rsync -P -r dyne.org::dynebolic-dev-anon/dyneII-kernel/ kernel

  cd - > /dev/null

  notice "the SDK has been succesfully created!"
  echo
  act "to make the system bootable setup your bootloader accordingly"
  act "for a fresh bootloader install run:"
  act "grub-install --root-directory=$SETTLE \"(hdX)\""
  act "please refer to the documentation of grub for further information"
  act "an example grub.conf and lilo.conf entry is also in ${DYNE_SYS_MNT}/dyne"
  act "happy hacking! ;)"
  echo
  
}



mkinitrd() {
    notice "making the initrd compressed filesystem"

    # cleanup if needed
    if [ -x $PFX/initrd ]; then
        rm -rf $PFX/initrd
    fi
  
    mkdir -p $PFX/initrd
    cd $PFX/initrd

    act "creating the ramdisk filesystem"
    cp -ra /etc .
    cp -ra /lib .
    cp -ra /bin .
    cp -ra /sbin .
    mkdir boot dev proc rem root sys usr var vol mnt home
    ln -s /usr usr/share
    ln -s /etc/terminfo usr/terminfo
    echo "# Ramdisk version $DYNE_INITRD_VER" > /boot/dynenv

    act "cleaning up configs and logs"
    rm -f etc/X11/XF86Config
    rm -f etc/HOSTNAME etc/NETWORK
    rm -f etc/auto.removable

   
    if [ -x $PFX/startup/.svn ]; then
	act "setup startup files from subversion repository"
	cp -vf $PFX/startup/rc_*     etc/
	cp -vf $PFX/startup/zshenv   etc/
	cp -vf $PFX/startup/inittab  etc/
	for f in `ls $PFX/startup/zsh/`; do
		cp -avf ${PFX}/startup/zsh/${f} etc/zsh/
	done
        for f in `ls $PFX/startup/init.d/`; do
		cp -avf ${PFX}/startup/init.d/${f} etc/init.d/
	done
	for f in `ls $PFX/startup/X11/`; do
		cp -ravf ${PFX}/startup/X11/${f} etc/X11/
	done
	for f in `ls $PFX/startup/lib/`; do
		cp -ravf ${PFX}/startup/lib/${f} lib/dyne/
	done
    fi

    if [ -r /etc/rc.local ]; then
	act "including /etc/rc.local startup settings"
	cp -vf /etc/rc.local etc/
    fi

    ######## KERNEL MODULES

    if [ -z $KRN ]; then KRN=`uname -r`; fi

    if [ -x /mnt/usr/lib/modules ]; then
      MODDIR=/mnt/usr/lib/modules
    else MODDIR=/usr/lib/modules; fi

    act "setup boot kernel modules for ${KRN}"
    mkdir -p boot/modules/${KRN}
    for m in `iterate $SUPPORTED_FS`; do
	M=`find ${MODDIR}/${KRN}/ -name "${m}.ko"`
	cp -v ${M} boot/modules/${KRN}/
    done

    # copy also the loopback device and samba modules
    cp -v `find ${MODDIR}/${KRN}/ -name "loop.ko"` boot/modules/${KRN}/
    cp -v `find ${MODDIR}/${KRN}/ -name "smbfs.ko"` boot/modules/${KRN}/

    # copy any additional module specified on commandline
    if [ $ADD_RAMDISK_MODULES ]; then
      act "adding extra modules selected on commandline"
      for m in `iterate $ADD_RAMDISK_MODULES`; do
    	  M=`find ${MODDIR}/${KRN}/ -name "${m}.ko"`
	  if [ -r ${M} ]; then
	    cp -vu ${M} boot/modules/${KRN}/
	  else
	    error "module ${m} not found"
          fi
      done
    fi

    cd - > /dev/null
    cd $PFX

    #### COPY THE KERNEL
    ## this is not really inside the ramdisk initrd
    ## but we do it here
    # form a default SDK location path
    SDK_KERNEL=${PFX}/kernel/linux/arch/`uname -i`/boot/bzImage 
    if [ -r ${SDK_KERNEL} ]; then

      act "new kernel found in SDK build"
      cp -v ${PFX}/${SDK_KERNEL} cdrom/dyne/linux

    elif [ -r ${DYNE_SYS_MNT}/dyne/linux ]; then

      act "kernel found in current dock"
      cp -v ${DYNE_SYS_MNT}/dyne/linux cdrom/dyne/linux

    elif [ -r cdrom/dyne/linux ]; then

      act "kernel already present in SDK"

    else
      error "kernel linux-${KRN} not found in /boot"
      error "aborting operation: you should build a kernel!"
      exit -1 
    fi
	     
    act "generate device file"
    dd if=/dev/zero of=cdrom/dyne/initrd bs=1k count=9000
    act "formatting ramdisk filesystem"
    mke2fs -m 0 -i 1024 cdrom/dyne/initrd
    act "populating ramdisk static file"
    mkdir -p tmp
    mount -o loop,rw cdrom/dyne/initrd tmp
    cp -ra initrd/* tmp
    rm -r tmp/lost+found
    umount tmp
    rm -r tmp
    rm -rf initrd

    act "tuning filesystem"
    tune2fs -c 0 -i 0 cdrom/dyne/initrd
    rm -f cdrom/dyne/initrd.gz
    gzip -9 cdrom/dyne/initrd
    act "`stat cdrom/dyne/initrd.gz`"
    cd - > /dev/null
    sync
}

mkhome() {
    notice "packaging /home";
    cd $PFX
    if [ -x home ]; then rm -rf home; fi
    cp -ra /home/luther home
    rm -rf home/.mozilla
    rm -f  home/.ssh/known_*
    # touch to avoid errors on zsh host completion
    touch  home/.ssh/known_hosts
    touch  home/.ssh/known_hosts2
    tar cfz cdrom/dyne/home.tgz home
    rm -rf home
    act "`stat $PFX/cdrom/dyne/home.tgz`"
    cd - > /dev/null ; sync
}

mkvar() {
    notice "packaging /var";
    if [ -x var ]; then rm -rf var; fi
    cd $PFX
    mkdir var
    cp -ra /var/* var/
    rm -rf var/local/*
    rm -rf var/cache/*
    rm -rf var/lock/*
    rm -rf var/tmp/*
    rm -rf var/run/*
    rm -rf var/log/*
    mkdir -p var/log/hotplug var/log/login var/log/setup
    mkdir -p var/cache/samba var/cache/union
    tar cfz cdrom/dyne/var.tgz var
    act "`stat cdrom/dyne/var.tgz`"
    rm -rf var
    cd - > /dev/null; sync
}

mksquash() {
    notice "making the /usr squashed filesystem (please wait, takes long!)"
    act "start compressing: `date`"
    $MKSQUASHFS /usr $PFX/cdrom/dyne/dyne.sys -noappend
    chmod -x $PFX/cdrom/dyne/dyne.sys
    act "end: `date`"
    act "`stat $PFX/cdrom/dyne/dyne.sys`"
    sync
}

mkiso() {
    notice "making the dyneII ISO"
    if ! [ -x ${PFX}/cdrom/devel ]; then mkdir -p ${PFX}/cdrom/devel; fi
    cp -f `which $0` $PFX/cdrom/devel/
    echo "# Forged on `hostname`.`dnsdomainname` the `date` " \
    	| tee $PFX/cdrom/dyne/VERSION
    echo "# using `$MKISOFS --version` on `uname -srm`" \
    	| tee -a $PFX/cdrom/dyne/VERSION
    echo >> $PFX/cdrom/dyne/VERSION
    DYNE_SYS_VER="`cat /usr/etc/DYNEBOLIC`"
    echo "DYNE_SYS_VER=$DYNE_SYS_VER" | tee -a $PFX/cdrom/dyne/VERSION
#    echo "MD5: `md5sum $PFX/cdrom/dyne/dyne.sys`" | tee -a $PFX/cdrom/VERSION
#    echo >> $PFX/cdrom/VERSION
    DYNE_INITRD_VER="`cat $PFX/initrd/etc/DYNEBOLIC`"
    echo "DYNE_INITRD_VER=$DYNE_INITRD_VER" | tee -a $PFX/cdrom/dyne/VERSION
    if [ -z $QUICK ]; then
    # generate md5sum hashes and gpg signatures in separate files
      rm $PFX/cdrom/dyne/*.md5 2>/dev/null 1>/dev/null
      rm $PFX/cdrom/dyne/*.asc 2>/dev/null 1>/dev/null
      echo "please wait while generating md5 sums"
      md5sum $PFX/cdrom/dyne/dyne.sys > $PFX/cdrom/dyne/dyne.sys.md5
      md5sum $PFX/cdrom/dyne/initrd.gz > $PFX/cdrom/dyne/initrd.gz.md5
      echo "cryptographically signing the md5 sums"
      gpg -b -a $PFX/cdrom/dyne/dyne.sys.md5
      gpg -b -a $PFX/cdrom/dyne/initrd.gz.md5
    fi
    act "purging subversion files in the cdrom"
    for svn in `find $PFX/cdrom -name '.svn'`; do
      rm -rf ${svn}
    done
    ISO=dyne-${DYNE_SYS_VER}.iso
    act "proceeding to pack the ISO image $ISO"
    $MKISOFS -o $PFX/$ISO -J -R -udf \
            -b isolinux/isolinux.bin -c isolinux/boot.cat \
            -no-emul-boot -boot-load-size 4 -boot-info-table \
	    $PFX/cdrom/
    act "`stat $PFX/$ISO`"
    sync
}

mkmods() {
    notice "compressing the modules in the cdrom"
    if ! [ -x ${PFX}/modules ]; then
	error "nothing in SDK/modules - are you really developing a module?"
	exit -1
    fi

    for mod in `ls --color=none ${PFX}/modules`; do

	if ! [ -r ${PFX}/modules/${mod}/VERSION ]; then
	    error "module ${mod} misses VERSION information: skipped"
	    continue
	fi
	
	act "compressing ${PFX}/cdrom/dyne/modules/${mod}"
	act "please wait, this may take a while..."

	mkdir -p ${PFX}/cdrom/dyne/modules

	$MKSQUASHFS ${PFX}/modules/${mod} ${PFX}/cdrom/dyne/modules/${mod}.dyne
	
	act "done with ${mod}"
	echo

    done

    chmod -x  $PFX/cdrom/dyne/modules/*.dyne
    chmod a+r $PFX/cdrom/dyne/modules/*.dyne

    act "modules were succesfully compressed in ${PFX}/cdrom/dyne/modules"
    ls -lh $PFX/cdrom/dyne/modules/*.dyne
}

########################################################################

case "$CMD" in
    # execute commands
    mksdk)    mksdk    ;;
    mkinitrd) mkinitrd ;;
    mkhome)   mkhome   ;;
    mkvar)    mkvar    ;;
    mksquash) mksquash ;;
    mkiso)    mkiso    ;;
    mkmods)   mkmods   ;;
    
    *) error "command \"$CMD\" not recognized"
esac

notice "bye."
exit 1
